# ADR-0008: Dev Environment Reproducible via Docker Compose

## Status
Accepted

## Context
El Payment Orchestrator depende de infraestructura externa (SQL Server, broker de mensajes, y eventualmente un store NoSQL).  
En proyectos enterprise, las inconsistencias de entorno (versiones, puertos, credenciales, “en mi máquina anda”) suelen generar:
- onboarding lento y fricción entre devs,
- tests de integración frágiles,
- debugging costoso por diferencias local vs CI,
- baja confiabilidad al iterar sobre features distribuidas (outbox, webhooks, workers).

Necesitamos un entorno local:
- **reproducible** (1 comando),
- **estable** (versiones fijas, healthchecks),
- **cercano a producción** (servicios reales, no mocks),
- **seguro** (sin secretos commiteados),
- **apto CI** (fácil de levantar en pipelines).

## Decision
Adoptamos **Docker Compose** como mecanismo estándar para levantar dependencias de desarrollo:

- SQL Server (ACID, source of truth transaccional)
- RabbitMQ (mensajería asíncrona, paridad con escenarios on-prem)
- MongoDB (read model / proyecciones y/o almacenamiento documental)

Principios operativos:
1. **Single command**: `docker compose up -d` levanta todo.
2. **Healthchecks**: cada servicio expone healthchecks para habilitar readiness (evitar condiciones de carrera).
3. **Secrets fuera del repo**: las credenciales se inyectan por variables de entorno mediante `.env` (ignorado) y se provee `.env.example` (commiteado).
4. **Version pinning**: imágenes con tags explícitos (p.ej. SQL 2022, Mongo 7, RabbitMQ 3-management).
5. **Persistencia local** (opcional pero recomendado): volúmenes para evitar perder estado entre reinicios (útil para debugging).
6. **Port mapping explícito**: puertos estándar para facilitar tooling (sqlcmd, UI RabbitMQ, mongosh).

## Alternatives Considered
- **Instalación local sin contenedores** (SQL/Rabbit/Mongo instalados en la máquina):
  - Pros: performance nativa
  - Cons: frágil, difícil de replicar, onboarding lento, drift de versiones.
- **Mocks/in-memory** (SQLite/in-memory broker):
  - Pros: rápido para unit tests
  - Cons: no representa fallas/latencia/comportamiento real; insuficiente para outbox/webhooks/reintentos.
- **Dev Containers / Kubernetes local**:
  - Pros: mayor paridad aún
  - Cons: complejidad extra y costo cognitivo alto para una base de portfolio.

## Consequences
### Positive
- Onboarding rápido y determinista.
- Menos “it works on my machine”.
- Preparación directa para features distribuidas (outbox publisher, reconciliación, webhooks).
- Base sólida para tests de integración (Testcontainers o CI).

### Negative / Trade-offs
- Requiere Docker instalado y recursos mínimos de máquina.
- Algunos escenarios cloud-managed (Service Bus/Azure SQL/Cosmos) no son idénticos, pero el diseño mantiene la posibilidad de swap por abstracciones en Infrastructure.

## Notes
- `.env` se ignora en git para evitar secrets en repo.
- Se mantiene documentación en README sobre cómo levantar y diagnosticar servicios (puertos, credenciales, healthchecks).
